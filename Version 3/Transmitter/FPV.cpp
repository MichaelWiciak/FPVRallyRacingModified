// Contains some common code for the FPV Rally Racing car  - primarily to setup hardware, transmit binding info, handle the throttle and steering and run a test

#include "FPV.h"
#include "Menu.h"  // For the menu system
#include "Radio.h" // For the radio
#include <Wire.h>  // This and the next two are for the motion sensor
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Preferences.h> // This one for storing configuration to non-volatile memory (not lost when you power off)

Adafruit_MPU6050 mpu;

Preferences preferences;

int throttleLow;    // The magnetic sensor value when throttle not pressed in
int throttleHigh;   // The magnetic sensor value when throttlw pressed in
uint16_t unitNum=0; // The number of my car.  It is a 15 bit number that is randomly generated by the transmitter the first time you go into race mode after powering on 

void FPVSetup()
{
  // Configure the switches - A and B are the bottom paddles, D1-6 are the top red buttons, and D7-9 are spares on the PCB for future use
  pinMode(swA, INPUT_PULLUP);
  pinMode(swB, INPUT_PULLUP);
  pinMode(d1, INPUT_PULLUP);
  pinMode(d2, INPUT_PULLUP);
  pinMode(d3, INPUT_PULLUP);
  pinMode(d4, INPUT_PULLUP);
  pinMode(d5, INPUT_PULLUP);
  pinMode(d6, INPUT_PULLUP);
  pinMode(d7, INPUT_PULLUP);
  pinMode(d8, INPUT_PULLUP);
  pinMode(d9, INPUT_PULLUP);
  
  // Setup the accelerometer to detect steering wheel tilt ...
  Wire.begin(27,22); // It's an I2C device so needs this
  mpu.begin();
  mpu.setAccelerometerRange(MPU6050_RANGE_2_G); // valid options 2,4,8,16
  mpu.setGyroRange(MPU6050_RANGE_500_DEG); // valid options 250,500,1000,2000 degrees/sec - We're not currently using the gyro - just the accelerometer
  mpu.setFilterBandwidth(MPU6050_BAND_5_HZ); // valid options 5,10,21,44,94,184,260 hz - think this is for the gyro again

  // Load T0 and T1 from non-volatile memory (these are the calibration constants for the throttle)
  preferences.begin("FPV", false);
  throttleLow = preferences.getInt("T0",0);
  throttleHigh = preferences.getInt("T1",0);
  preferences.end();
  
  // If either bottom paddle pressed, go into test mode
  if ((digitalRead(swA)==LOW) || (digitalRead(swB)==LOW))
    doTest();
}

void bindIfNeeded() // If we've not come up with a random unit number for this transmitter, do so, and transmit it to a listening receiver
{
  int i;

  int randomY = 10;
  int speedY  = 1;
  
  if(unitNum==0)
  {

    // can update the 'binding' screen here
    
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_7x13B_mr);
    u8g2.drawStr(0,50,"Binding ...");

    // can update here
    u8g2.drawDisc(60, randomY, 10);
    u8g2.drawDisc(80, randomY, 5);
    u8g2.drawDisc(95, randomY, 3);
    u8g2.drawDisc(105, randomY, 2);
    u8g2.drawDisc(110, randomY, 1);

    
    u8g2.sendBuffer();
    randomSeed(millis());
    unitNum = 0;
    while (unitNum==0) // unit must not be zero as that indicates it is not bound yet, so just keep generating random numbers until it isn't zero! ...
      unitNum = random(0,65535) & 0x7fff; // get rid of top bit as that indicates binding mode
     
    outgoingRadioPacket.unitNum = unitNum | 0x8000; // Now set top bit and broadcast for 1 second to bind
    for(i=1; i<=100; i++)
    {
      sendPacket();
      delay(10);
    }
    outgoingRadioPacket.unitNum = unitNum; // Get rid of top bit again for normal driving as we should now have bound
  }
}

int isCalibrated() // Returns 0 and displays message if throttle not calibrated yet
{
  if ((throttleLow==0) || (throttleHigh==0))
  {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_7x13B_mr);
    u8g2.drawStr(0,10,"Please Calibrate");
    u8g2.drawStr(0,24,"from Config Menu");
    u8g2.sendBuffer();
    delay(2000); // Delay long enough to read message
    return 0;  
  }
  else
    return 1;
}

void calibrateThrottle() // Calibrates the throttle
{
  throttleLow = analogRead(mag2); // this is the magnetic sensor reading with no throttle
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_7x13B_mr);
  u8g2.drawStr(0,10,"Floor Throttle");
  u8g2.drawStr(0,24,"and press bottom");
  u8g2.drawStr(0,38,"left paddle ...");
  u8g2.sendBuffer();
  while(digitalRead(swA)==HIGH); // Wait until bottom left paddle is hit
  throttleHigh = analogRead(mag2); // this is the sensor readng with full throttle
  u8g2.clearBuffer();
  u8g2.sendBuffer(); 
  // Now store these calibration values in non-volatile memory
  preferences.begin("FPV", false);
  preferences.putInt("T0", throttleLow);
  preferences.putInt("T1", throttleHigh);
  preferences.end();
}

int getThrottle(int throttleMax) // returns the value for throttle position
{
  int throttleRange = throttleLow-throttleHigh;
  long currentThrottle = analogRead(mag2);
  currentThrottle = currentThrottle-throttleHigh;
  currentThrottle = throttleMax-(throttleMax*currentThrottle/throttleRange);
  if(currentThrottle<0) currentThrottle=0;
  if(currentThrottle>throttleMax) currentThrottle=throttleMax;
  if(digitalRead(swB)==LOW) // Reverse if switch B held down
    currentThrottle = 0-currentThrottle;
  else if (digitalRead(swA)==HIGH)
    currentThrottle = 0; // Cut motors if nether switch held down
  return currentThrottle;  
}

int getSteering(int steeringMax) // returns value for steering position
{
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);
  int angle = a.acceleration.y*10;
  return map(angle,100,-100,90-steeringMax,90+steeringMax);  
}

void doTest()
{
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_7x13B_mr);
  while(digitalRead(ENC_SW)==HIGH)
    {
      u8g2.clearBuffer();          // clear the internal memory
      // Show if any of the bottons pressed ...
      if((digitalRead(swA)==LOW)) { u8g2.drawStr(8*0, 10,"A"); }
      if((digitalRead(swB)==LOW)) { u8g2.drawStr(8*1, 10,"B"); }
      if((digitalRead(d1)==LOW)) { u8g2.drawStr(8*2, 10,"1"); }
      if((digitalRead(d2)==LOW)) { u8g2.drawStr(8*3, 10,"2"); }
      if((digitalRead(d3)==LOW)) { u8g2.drawStr(8*4, 10,"3"); }
      if((digitalRead(d4)==LOW)) { u8g2.drawStr(8*5, 10,"4"); }
      if((digitalRead(d5)==LOW)) { u8g2.drawStr(8*6, 10,"5"); }
      if((digitalRead(d6)==LOW)) { u8g2.drawStr(8*7, 10,"6"); }
      int reading;
      reading = analogRead(39); // IO 39 is ocnnected to voltage divider from battery so we can measure it's voltage
      float voltage;
      // The following code makes the voltage reading more linear as the ADC in the ESP32 is not great!
      voltage = -0.000000000000016 * pow(reading, 4) + 0.000000000118171 * pow(reading, 3) - 0.000000301211691 * pow(reading, 2) + 0.001109019271794 * reading + 0.034143524634089;
      reading = voltage*20;
      // Now display the battery voltage ...
      static char buf[10];
      buf[0]=(reading / 10)+'0';
      buf[1]='.';
      buf[2]=(reading % 10)+'0';
      buf[3] = 'V';
      buf[4] = 0;
      u8g2.drawStr(0, 23, buf);

      // Now get the motion sensor data ...
      sensors_event_t a, g, temp;
      mpu.getEvent(&a, &g, &temp);

      // ... and print angle of steering wheel ...
      u8g2.drawStr(0,38,"Tilt:");
      u8g2.setCursor(70,36);
      u8g2.print(a.acceleration.y);
      
      // ... and display raw values of top paddles
      reading = analogRead(mag1);
      u8g2.drawStr(0,49,"Mag1:");
      u8g2.setCursor(70,49);
      u8g2.print(reading);

      reading = analogRead(mag2);
      u8g2.drawStr(0,62,"Mag2:");
      u8g2.setCursor(70,62);
      u8g2.print(reading);

      u8g2.sendBuffer(); // Finally display what we have drawn on the OLED screen
      delay(50);
    }
}
